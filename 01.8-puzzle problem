from collections import deque

# Function to find the position of a number in the puzzle
def find_position(puzzle, num):
    for i in range(len(puzzle)):
        for j in range(len(puzzle[i])):
            if puzzle[i][j] == num:
                return (i, j)

# Function to find the Manhattan distance between two positions
def manhattan_distance(pos1, pos2):
    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

# Function to get the neighbors of a state
def get_neighbors(state):
    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # possible moves: right, left, down, up
    neighbors = []
    zero_pos = find_position(state, 0)

    for move in moves:
        new_pos = (zero_pos[0] + move[0], zero_pos[1] + move[1])
        if 0 <= new_pos[0] < 3 and 0 <= new_pos[1] < 3:
            new_state = [row[:] for row in state]  # Create a copy of the current state
            new_state[zero_pos[0]][zero_pos[1]], new_state[new_pos[0]][new_pos[1]] = \
                new_state[new_pos[0]][new_pos[1]], new_state[zero_pos[0]][zero_pos[1]]  # Swap zero with the number
            neighbors.append(new_state)

    return neighbors

# Function to calculate the total cost of the path
def total_cost(path):
    cost = 0
    for i in range(1, len(path)):
        cost += 1  # Each step has a cost of 1
    return cost

# Function to calculate the heuristic (Manhattan distance) for a state
def heuristic(state, goal_state):
    total_h = 0
    for num in range(1, 9):
        goal_pos = find_position(goal_state, num)
        current_pos = find_position(state, num)
        total_h += manhattan_distance(current_pos, goal_pos)
    return total_h

# Function to solve the 8-puzzle problem using A* algorithm
def solve_8_puzzle(initial_state, goal_state):
    open_list = [(0 + heuristic(initial_state, goal_state), 0, initial_state, [])]  # (f = g + h, g, state, path)
    closed_list = set()

    while open_list:
        f, g, current_state, path = open_list.pop(0)
        if current_state == goal_state:
            return path, g  # Return the solution path and its cost

        closed_list.add(tuple(map(tuple, current_state)))

        for neighbor in get_neighbors(current_state):
            if tuple(map(tuple, neighbor)) not in closed_list:
                g_neighbor = g + 1
                f_neighbor = g_neighbor + heuristic(neighbor, goal_state)
                open_list.append((f_neighbor, g_neighbor, neighbor, path + [current_state]))
                open_list.sort()

    return None, None  # If no solution found

# Function to print the puzzle state
def print_puzzle(state):
    for row in state:
        print(' '.join(map(str, row)))
    print()

if __name__ == "__main__":
    print("Enter the initial state of the puzzle (use 0 for the blank space):")
    initial_state = []
    for _ in range(3):
        row = list(map(int, input().split()))
        initial_state.append(row)

    print("\nEnter the goal state of the puzzle (use 0 for the blank space):")
    goal_state = []
    for _ in range(3):
        row = list(map(int, input().split()))
        goal_state.append(row)

    print("\nInitial state:")
    print_puzzle(initial_state)
    print("Goal state:")
    print_puzzle(goal_state)

    solution_path, cost = solve_8_puzzle(initial_state, goal_state)

    if solution_path:
        print("Solution found with cost:", cost)
        print("Steps to solve:")
        for step, state in enumerate(solution_path):
            print("Step", step + 1)
            print_puzzle(state)
    else:
        print("No solution found.")
